---
title: "Functional principal component analysis for spatial summary functions"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Multiplex FPCA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  figs.out = "../figures"
)
invisible(suppressPackageStartupMessages(library(tidyverse)))
```

The `{mxfda}` package contains tools for analyzing single-cell multiplex imaging data using methods from functional data analysis. Analyses for this package are executed and stored using an S4 object of class `mxFDA`. This vignette outlines how to perform feature extraction using functional principal component analysis and multilevel functional principal component analysis. To set up an `mxFDA` object from spatial single cell imaging data, calculate spatial summary functions, and perform exploratory data analysis and visualization of these spatial summary functions, see `vignette("mx_fda")`. To perform functional regression on spatial summary functions from multiplex imaging data, see  `vignette("mx_funreg")`.


```{r setup}
library(mxfda)
library(tidyverse)
library(patchwork)
```


# Functional data notation

The basic unit of observation is the curve $X_i(r)$ for subjects $i \in \ldots, I$ in the cross-sectional setting and $X_{ij}(r)$ for subject $i$ at sample $j \in \ldots, J_i$ for the multilevel structure, which occurs when there are multiple samples for each subject. Methods for functional data are typically presented in terms of continuous functions, but in practice data are observed on a discrete grid, $t$. In the `{mxfda}` package, $X_{ij}(r)$ is the spatial summary function (for example, Ripley's K) value at radius $r$ for sample $j$ from subject $i$.


# Functional principal components analysis (FPCA)

## Background on FPCA


FPCA characterizes modes of variability by decomposing functional observations into population level basis functions and subject-specific scores. The basis functions have a clear interpretation, analogous to that of PCA: the first basis function explains the largest direction of variation, and each subsequent basis function describes less. The FPCA model is typically written


$$
X_i(r) = \mu(r) + \sum_{k=1}^{K} c_{ik}\psi_{k}(r) + \epsilon_i(r)
$$

where $\mu(r)$ is the population mean, $\psi_{k}(r)$ are a set of orthonormal population-level functional principal components, $c_{ik}$ are subject-specific scores with mean zero and variance $\lambda_k$, and $\epsilon_i(r)$ are residual curves. Estimated functional principal components $\widehat{\psi}_1(r), \widehat{\psi}_2(r), \ldots, \widehat{\psi}_{K}(r)$ and corresponding variances $\widehat{\lambda}_1 \geq \widehat{\lambda}_2 \geq \ldots \geq \widehat{\lambda}_K$ are obtained from a truncated Karhunen-Lo\`eve decomposition of the sample covariance $\widehat{\Sigma}(s,t) = \widehat{\mbox{Cov}}(Y_i(s), X_i(r))$. The truncation lag $K$ is often chosen so that the resulting approximation accounts for at least 95\% of observed variance (@wrobel2016interactive). 

Conceptually, functional principal components can be thought of as patterns in the data that explain the most variance, and scores $c_{ik}$ are weights that describe how much each functional principal component contributes to the shape of a given subject's spatial summary function.


## Implementing FPCA

### Load and visualize data

Here we load data from the [VectraPolarisData](https://bioconductor.org/packages/release/data/experiment/html/VectraPolarisData.html) ovarian cancer dataset, which contains tumor microarray data for 128 women with high-grade serous ovarian cancer, where univariate nearest-neighbor G-functions for immune cells have already been extracted. This data has been modified, but the original data and experiment are described in @steinhart2021spatial. Each subject has one image.

```{r}
data("ovarian_FDA")
ovarian_FDA
```

These functions are visualized below.

```{r}
plot(ovarian_FDA, y = "fundiff", what = "uni g", sampleID = "patient_id") +
  geom_hline(yintercept = 0, color = "red", linetype = 2) +
  theme_minimal() 
  
```

Values above the dotted red line are interpreted as having a higher probability of observing a neighboring immune cell at radius $r$ than would be expected under complete spatial randomness. Conversely, values below the dotted line exhibit lower probability of observing a neighboring immune cell than expected under CSR.

### Run and visualize FPCA

Below we run FPCA on these G-function curves, using the `run_fpca()` function, and store these results in the `mxFDAobject` called `ovarian_FDA`. The argument `metric` is used to specify which spatial summary function to estimate FPCA for- in this case "uni g" specifies the univariate G function, `r` denotes which variable specifies the radius, and `value` denotes which value are the values of the spatial summary function. The argument `pve` takes a number from 0 to 1, and specifies the percent variance explained by the FPCA decomposition. For example, if `pve= 0.98` is selected, the resulting FPCA will return the number of FPCs that explain 98% of variance in the data.

```{r}
ovarian_FDA <- run_fpca(ovarian_FDA, 
                        metric = "uni g", 
                        r = "r", 
                        value = "fundiff",
                        pve = .95)

```

Note that the summary of this object now shows the number of functional principal components (FPCs) that have been calculated:

```{r}
summary(ovarian_FDA)
```


The FPCA results are stored in the `functional_pca` slot of the  `ovarian_FDA` object. To access this slot directly and view the extracted summary functions, type: 


```{r, eval = FALSE}
ovarian_FDA@functional_pca
```





Explain each of these plots



```{r fpc_plots, fig.width = 10}

p1 = plot(ovarian_FDA, what = 'uni g fpca', pc_choice = 1)
p2 = plot(ovarian_FDA, what = 'uni g fpca', pc_choice = 2)
p3 = plot(ovarian_FDA, what = 'uni g fpca', pc_choice = 3)
p4 = plot(ovarian_FDA, what = 'uni g fpca', pc_choice = 4)

(p1 + p2)/(p3 + p4)
```


INTERPRET WHAT YOU LEARNED FROM FPCA- this is an important piece


Shout out to refund.shiny

```{r refund.shiny, eval = FALSE}
G_fpca = extract_fpca_object(ovarian_FDA,
                             what = "uni g fpca", r = "r")
class(G_fpca)
#library(refund.shiny)
#plot_shiny(G_fpca)

```



# MFPCA


## MFPCA Background 

Background on mfpca

Multilevel functional principal components analysis (MFPCA) extends the ideas of FPCA to functional data with a multilevel structure.


Multilevel functional data are increasingly common in practice; in the case of our DTI example, this structure arises from multiple clinical visits made by each subject. MFPCA models the within-subject correlation induced by repeated measures as well as the between-subject correlation modeled by classic FPCA. This leads to a two-level FPC decomposition, where level 1 concerns subject-specific effects and level 2 concerns visit-specific effects. Population-level basis functions and subject-specific scores are calculated for both levels \citep{di2009, di2014}. The MFPCA model is:

$$
	X_{ij}(r) = \mu(r)  + \sum_{k_1=1}^{K_1} 	c_{ik}^{(1)}\psi_{k}^{(1)}(r) + \sum_{k_2=1}^{K_2}c^{(2)}_{ijk}\psi_{k}^{(2)}(r) + \epsilon_{ij}(r)
$$

\noindent 
where $\mu(r)$ is the population mean,  $\eta_j(r)$ is the visit-specific shift from the overall mean, $\psi_{k}^{(1)}(r)$ and $\psi_{k}^{(2)}(r)$ are the eigenfunctions for levels 1 and 2, respectively, and $c_{ik}^{(1)}$ and $c^{(2)}_{ijk}$ are the subject-specific and subject-visit-specific scores. Often, visit-specific means $\eta_j(r)$ are not of interest and can be omitted from the model. Estimation for MFPCA extends the approach for FPCA: estimated between- and within-covariances $\widehat{\Sigma}^{(1)}(s,t) = \widehat{\mbox{Cov}}(Y_{ij}(s), Y_{ij'}(r))$ for $j \neq j'$ and $\widehat{\Sigma}^{(2)}(s,t) = \widehat{\mbox{Cov}}(Y_{ij}(s), X_{ij}(r))$ are derived from the observed data, smoothed, and decomposed to obtain eigenfunctions and values. Given these objects, scores are estimated in a mixed-model framework.


## Implementing MFPCA

Explain that there are multiple curves per subject for MFPCA and that's why lung data is better for mfpca

### Extract spatial summary functions and visualize data

Here we extract the univariate K function from the lung data. With summary functions within the `{mxfda}` package, they use a window created by the subset of cells rather than all cells in a core. This is something to keep in mind.

```{r}
data(lung_df)
clinical = lung_df %>%
  select(image_id, patient_id, patientImage_id, gender, age, survival_days, survival_status, stage) %>%
  distinct()

spatial = lung_df %>%
  select(-image_id, -gender, -age, -survival_days, -survival_status, -stage)

mxFDAobject = make_mxfda(metadata = clinical,
                         spatial = spatial,
                         subject_key = "patient_id",
                         sample_key = "patientImage_id"
                         )

mxFDAobject = extract_summary_functions(mxFDAobject, 
                                        extract_func = extract_univariate,
                                        summary_func = Kest,
                                        r_vec = seq(0, 100, by = 1),
                                        edge_correction = "iso",
                                        markvar = "immune",
                                        mark1 = "immune")


```


Visualize

```{r}
plot(mxFDAobject, y = "fundiff", what = "uni k", sampleID = "patientImage_id") +
  geom_hline(yintercept = 0, color = "red", linetype = 2)
```

Do some summaries (how many total functions? How many subjects? Range of number of functions per subject?)

### Run and visualize MFPCA

Right now this takes the same id in both slots and splits it under the hood. need to change this behavior


```{r}
# see what happens when you use mfpca.sc as an engine
mxFDAobject <- run_mfpca(mxFDAobject, 
                       metric = "uni k", r = "r", 
                       value = "fundiff",
                       pve = .99,
                       lightweight = FALSE)
```


Explore FPCA object

```{r}
#plot mxFDA object mFPCA
p = plot(mxFDAobject, what = 'uni k mfpca', level1 = 1, level2 = 3)

p[[1]] + p[[2]]

#library(refund.shiny)
#plot_shiny(mfpca)
```

Calculate variance of level 2 scores. Also, are the 

```{r}

```




ICC



# FDA Tips / Principles/ Things to know

* Sparse vs. even grids- mention these, and what types of analysis you can do with each
* Better to have 20+ measurements per curve- that means using a dense grid of radii
* Number of knots cannot exceed the number of datapoints per function

# References
