---
title: "Functional regression with spatial summary functions as covariates"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{mx Functional Regression}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  fig.width = 8
)
invisible(suppressPackageStartupMessages(library(tidyverse)))
```

The `{mxfda}` package contains tools for analyzing single-cell multiplex imaging data using methods from functional data analysis. Analyses for this package are executed and stored using an S4 object of class `mxFDA`. This vignette outlines how to perform functional regression using spatial summary functions of multiplex image samples as model covariates. To set up an `mxFDA` object from spatial single cell imaging data, calculate spatial summary functions, and perform exploratory data analysis and visualization of these spatial summary functions, see `vignette("mx_fda")`. To perform feature extraction using functional principal component analysis, see `vignette("mx_fpca")`.


**Note: Right now, the `{mxfda}` package focuses on regression problems with survival outcomes. In the future, the package will be extended to handle other outcome types, including continuous and binary data.**

```{r setup}
library(mxfda)
library(tidyverse)
library(patchwork)
library(broom)
```


## Ovarian cancer multiplex imaging data

Here we load data from the Ovarian cancer dataset where univariate nearest-neighbor G-functions for immune cells have already been estimated. See the vignette `mxfda::mx_fda` for more details on extracting spatial summary functions.


```{r load_data}
data("ovarian_FDA")
```


We visualize these functions below.

```{r}
plot(ovarian_FDA, y = "fundiff", what = "uni g") +
  geom_hline(yintercept = 0, color = "red", linetype = 2) +
  theme_minimal() +
  ggtitle("Nearest neighbor G-functions for immune cells")
  
```


## Functional regression models for survival outcomes

Single-cell multiplex imaging is common in cancer applications, where the analysis goal is to relate cell-level spatial information to patient-level time-to-event outcomes like overall survival or time-to-recurrence. Cox regression is a popular regression technique for assessing the association between covariates and a survival outcome. The standard Cox model is given by

$$\log h_i(t) = \log h_0(t) + \sum_{p = 1}^P \gamma_p Z_{ip},$$

where $h_i(t)$ is the *hazard rate* for subject $i$ and $h_0(t)$ is an unspecified baseline hazard. Each $Z_{ip}$ is a scalar covariates., and $P$ is the total number of scalar covariates. These are covariates.s like age, sex, treatment group, etc and can be contrasted with spatial summary functions which are known as functional covariates.s. The $\gamma_p$ are regression coefficients; these are interpreted as log hazard ratios.

For multiplex imaging data, we have a spatial summary function for each subject (e.g. univariate Ripley's K), $X_i(r)$, that we want to add to the Cox regression model as a functional covariate. Below we provide three different strategies for incorporating $X_i(r)$ into a Cox regression model as a covariate.


### Cox regression using functional principal components as covariates

In this approach, we first decompose the spatial summary functions using FPCA, then use subject-specific scores from FPCA as covariates in a Cox regression model. Conceptually, we are fitting the model given by

$$\log h_i(t) = \log h_0(t) + \sum_{p = 1}^P \gamma_p Z_{ip} + \sum_{k = 1}^K \beta_k c_{ik},$$

where $c_{ik}$ is the $k$th score from functional principle components analysis for the $i$th subject. $K$ represents the number of principle components, usually selected to explain at least 95% of the variance in the spatial summary functions (see `vignette("mx_fpca")`).  The $\beta_k$ are regression coefficients that tell us about the association between overall survival and the $k$th functional principle component. Like the $\gamma_p$, the the $\beta_k$ are interpreted as log hazard ratios, and $e^{\beta_k}$ is a hazard ratio. This is the approach to Cox regression with spatial summary functions as covariates taken in @vu2023funspace.

The code below runs FPCA the the G-functions from the ovarian cancer data and calculates principle componts that explain up to 99% variance using the argument `pve`. The argument `lightweight = TRUE` returns only what is needed for downstream analysis. To return all items calculate by FPCA when using `refund::fpca.face`, use `lightweight = FALSE`.

```{r}
ovarian_FDA <- run_fpca(ovarian_FDA, metric = "uni g", r = "r", value = "fundiff",
                        lightweight = TRUE,
                        pve = .99)
ovarian_FDA
```

Six FPCs were returned. Below, we extract the fpca scores from the `ovarian_FDA` object and visualize the relationship between the first two FPC scores and survival time.   

```{r, fig.height = 8}
Gdf_fpc = extract_fpca_scores(ovarian_FDA, 'uni g fpca')

p1 = Gdf_fpc %>%
  mutate(event = factor(event, levels = 0:1, labels = c("censored", "died"))) %>%
  ggplot(aes(fpc1, survival_time, color = event)) +
  geom_point() + 
  labs(y = "survival time (days)", title = "fpc1") +
  theme(legend.position = c(.5, .7))

p2 = Gdf_fpc %>%
  mutate(event = factor(event, levels = 0:1, labels = c("censored", "died"))) %>%
  ggplot(aes(fpc2, survival_time, color = event)) +
  geom_point() + 
  labs(y = "survival time (days)", title = "fpc2") +
  theme(legend.position = "none")


p1 + p2
```


It appears that subjects with lower scores for FPC 1 tended to have longer survival times.

Next, we use these scores as covariates in a Cox regression model. We also control for age.

```{r}
library(survival)
phmod_fpc = coxph(Surv(survival_time, event) ~ fpc1 + fpc2 + fpc3 + fpc4 + age, 
              data = Gdf_fpc)
#summary(phmod_fpc)
```

The results from this model are printed below. Not that All FPCs except FPC 2 have a statisticaly significant relationship with overall survival. The hazard ratio above 1 for FPC 1 indicates that higher scores are associate with worse survival outcomes, which is consistent with the exploratory analysis in the plot above.

```{r}
tidy(phmod_fpc, exp = TRUE, conf.int = TRUE) %>%
  mutate(p.value = format.pval(p.value, digits = 1)) %>%
  select(term, hazard_ratio = estimate, conf.low, conf.high, p = p.value) %>%
  knitr::kable(digits = 2)
```


### Linear and additive functional Cox regression models

This is the approach used in @vu2022spf

Linear functional cox model takes the form: 

$$\log h_i(t;Z_i, X_i) = \log h_0(t) + \sum_{p = 1}^P \gamma_p Z_{ip} + H\left(X_i(r)\right)$$

Using age and gender and stage as scalar covariates


#### Linear functional Cox model (LFCM)

@gellar2015cox

```{r}
ovarian_FDA = run_fcm(ovarian_FDA, model_name = "fit_lfcm",
                      formula = survival_time ~ age, event = "event",
                      metric = "uni g", r = "r", value = "fundiff",
                      afcm = FALSE)
```

```{r}
class(extract_model(ovarian_FDA, 'uni g', 'fit_lfcm'))
```


```{r}
summary(extract_model(ovarian_FDA, 'uni g', 'fit_lfcm'))
```

Visualize coefficient function

```{r}
lfcm_surface = extract_surface(ovarian_FDA, metric = "uni g", model = "fit_lfcm", analysis_vars = c("age"))
plot(lfcm_surface)
```



#### Additive functional Cox model (AFCM)

@cui2021additive

```{r}
ovarian_FDA <- run_fcm(ovarian_FDA, model_name = "fit_afcm", 
                       formula = survival_time ~ age, event = "event",
                       metric = "uni g", r = "r", value = "fundiff",
                       afcm = TRUE)
```

```{r}
class(extract_model(ovarian_FDA, 'uni g', 'fit_afcm'))
```


```{r}
summary(extract_model(ovarian_FDA, 'uni g', 'fit_afcm'))
```


Visualize the afcm model

```{r extract_estimates, fig.with = 12}
afcm_surface = extract_surface(ovarian_FDA, metric = "uni g", model = "fit_afcm", analysis_vars = c("age"), p = 0.05)
plot(afcm_surface)

```

## Model summaries and C-index 

C-index is a good way to compare across models, especially when incorporating cross validation.

```{r}
# calculate overall p value for fpca
#fit_fpc_null = coxph(Surv(survival_time, event) ~  age, data = Gdf_fpc)
#p_fpc = anova(fit_fpc_null, phmod_fpc)

fit_afcm = extract_model(ovarian_FDA, 'uni g', 'fit_afcm')
fit_lfcm = extract_model(ovarian_FDA, 'uni g', 'fit_lfcm')

c_index = c(
  rep(phmod_fpc$concordance[["concordance"]], times = 4),
  extract_c(fit_lfcm, Gdf_fpc$survival_time, Gdf_fpc$event),
  extract_c(fit_afcm, Gdf_fpc$survival_time, Gdf_fpc$event)
)


est_fpca = broom::tidy(phmod_fpc, exp = TRUE) %>%
  mutate(model = "fpca", edf = NA) %>%
  select(model,  term, "hazard ratio" = estimate, edf, p = p.value)

est_lfcm = bind_rows(broom::tidy(fit_lfcm) %>% 
  mutate("hazard ratio" = NA, p = NA, model = "lfcm") %>%
  select(model, term, "hazard ratio", edf, p),
  broom::tidy(fit_lfcm, parametric = TRUE, exp = TRUE) %>% 
  mutate(edf = NA, model = "lfcm") %>%
  select(model, term, "hazard ratio" = estimate, edf, p = p.value)
)

est_afcm = bind_rows(broom::tidy(fit_afcm) %>% 
  mutate("hazard ratio" = NA, p = NA, model = "afcm") %>%
  select(model, term, "hazard ratio", edf, p),
  broom::tidy(fit_afcm, parametric = TRUE, exp = TRUE) %>% 
  mutate(edf = NA, model = "afcm") %>%
  select(model, term, "hazard ratio" = estimate, edf, p = p.value)
)

bind_rows(est_fpca, est_lfcm, est_afcm) %>%
  filter(term != "age") %>%
  mutate(p = format.pval(p, digits = 1),
         "c-index" = c_index) %>%
  knitr::kable(digits = 2)
```
